---
title: Giftify 친구 관계 모델링 트러블슈팅 로그
description: Friend vs Follow, 그리고 “일급 시민” 친구 관계를 어떻게 설계할 것인가
pubDate: 2026-02-12
updatedDate: 2026-02-12
tags:
  - 개발
draft: true
---
# Giftify 친구 관계 모델링 트러블슈팅 로그  
_Friend vs Follow, 그리고 “일급 시민” 친구 관계를 어떻게 설계할 것인가_

Giftify에서 “친구의 위시리스트에 펀딩을 거는” 기능을 설계하면서, 자연스럽게 **친구 관계 모델링** 문제에 부딪혔습니다. 이 글은 그 과정에서 실제로 고민했던 질문들의 순서를 따라가며, 어떻게 모델을 선택하고 정리했는지 기록한 트러블슈팅 로그입니다.

---

## 1. 출발점: Friend = Member–Member N:N 중간 테이블?

처음 다이어그램을 그렸을 때, 백엔드의 `Friendship`(혹은 Friend) 구조는 대략 이렇게 보였습니다.

- `requesterId`
- `receiverId`
- `status` (PENDING / ACCEPTED / REJECTED)

즉, Member와 Member의 N:N 관계를 **중간 엔티티**로 풀어낸 구조입니다.  
여기서 제가 던진 첫 질문은 이거였습니다.

> “Friend가 Member와 Member의 N:N 관계를 풀어내는 N:1 매핑 중간 테이블이면 되는 것이죠?”

답은 **그렇다**였습니다.  
하나의 Friendship row가 “두 Member 사이의 친구 관계 하나”를 나타내고,  
Member–Friendship–Member 구조로 보면,  
한 Member는 여러 Friendship의 requester/receiver가 될 수 있으니 결과적으로 Member–Member는 N:N, 그걸 중간에 풀어낸 형태입니다.

이 시점의 이해:

- **구조적으로는** 전형적인 “N:N → 중간 엔티티” 모델  
- 다만, 필드 이름 때문에 이 구조가 “단순한 조인 테이블인지, 도메인 엔티티인지”가 중요해지기 시작했습니다.

---

## 2. 두 번째 의문: requester/receiver라면 인스타처럼 “서로 팔로우” 구조인가?

다이어그램을 보면 `requesterId`, `receiverId`라는 필드가 명확히 있었습니다.  
그러다 보니 자연스럽게 이런 의문이 들었습니다.

> “requesterId, receiverId로 표현되는 것으로 보아 서로 팔로우를 해야 하는 이중 구조인가요? 인스타 팔로우처럼?”

여기서 정리한 핵심:

- 인스타/트위터식 모델은 보통 이렇게 생겼습니다.
  - `Follow(followerId, followeeId)`
  - 단방향 관계, 두 줄이 있어야 “서로 팔로우 중”
- 지금 Giftify의 `Friendship(requesterId, receiverId, status)`는 그게 아닙니다.
  - 한 줄이 “친구 관계 전체”를 의미
  - PENDING → ACCEPTED로 바뀌면 “A와 B는 서로 친구”로 취급

즉, 이 모델은 인스타식 “서로 팔로우 두 줄”이 아니라,  
**페이스북식 “요청 기반 양방향 친구” 한 줄**에 더 가깝다는 점이 드러났습니다.

이 단계에서 정리한 점:

- `requesterId/receiverId`가 있다고 해서 “서로 팔로우하는 두 줄”은 아니다.
- 한 줄의 `Friendship`이 “관계 그 자체”를 나타내고,  
  그 안에서 “누가 먼저 요청했는지”만 추가로 기록하고 있는 구조다.

---

## 3. 세 번째 질문: 인스타식 팔로우 + 요청/수락 모델로도 친구를 표현할 수 있지 않나?

그러다 다시 이런 생각이 들었습니다.

> “근데 인스타도 팔로우 요청 수락 같은 기능 있잖아요.  
> 그거라고 생각하면요? 단순한 두 관계로 친구 관계를 풀어낼 수 있지 않나요?”

여기서 한 번, “인스타식으로 친구를 정의하면 어떤 모습이 되는지”를 상상해봤습니다.

### 3.1. 인스타식 Follow로 친구 정의하기

예를 들어 다음과 같은 테이블만 있다고 해봅니다.

```text
Follow
- followerId
- followeeId
- status: PENDING / ACCEPTED / REJECTED
```

그러면 “친구”를 이렇게 정의할 수 있습니다.

- A와 B가 친구다  
  ⇔ `Follow(A → B).status = ACCEPTED` **그리고** `Follow(B → A).status = ACCEPTED`

장점:

- DB 테이블 구조는 단순합니다.  
  - 모든 관계는 “A가 B를 follow 한다” 하나뿐
- ‘친구’라는 개념을 별도 테이블로 만들지 않아도 됩니다.

하지만 단점이 동시에 드러났습니다.

- `isFriend(A,B)`를 체크하려면 항상 두 방향을 확인해야 합니다.
  - `Follow(A,B)`와 `Follow(B,A)`를 모두 조회 필요
- “친구 요청/수락” 플로우도 더 복잡하게 느껴집니다.
  - A→B 팔로우 요청(PENDING)
  - B가 A를 팔로우할 때 이걸 “친구 수락”으로 볼지, 따로 수락 API를 둘지 등 정책이 꼬이기 쉽습니다.
- 무엇보다, Giftify에서는 “친구”라는 개념이 도메인의 핵심이기 때문에,  
  이 중요한 개념이 **단지 “두 Follow의 조합 규칙”으로만 존재**하게 되는 게 걸렸습니다.

이 시점에서 나온 결론:

- **논리적으로는 가능하다.**  
  단방향 Follow 두 개로 친구를 정의할 수 있다.
- 하지만 Giftify에서 “친구”는 그냥 규칙이 아니라 **1급 시민 개념**이라,  
  “Friendship”이라는 명시적인 엔티티가 있는 것이 도메인 모델 측면에서 더 자연스럽다.

---

## 4. 네 번째 질문: requester / receiver의 비대칭 의미, 괜찮은가?

다음으로 마음에 걸린 포인트는 이거였습니다.

> “그러면 한쪽이 requester고 한쪽은 receiver인 비대칭적인 의미가 담기는데 괜찮은 걸까요?”

여기서 다시 한 번 “현재 관계 vs 과거 기록”을 분리해서 고민했습니다.

### 4.1. 비대칭은 “생성 시점의 메타 정보”로 보기

`Friendship(requesterId, receiverId, status=ACCEPTED)`를 이렇게 해석하면 부담이 줄어듭니다.

- **현재 상태**: 둘은 대칭적인 친구  
- **과거 정보**: 누가 먼저 친구 요청을 날렸는가 (initiator)

즉, 도메인에서 “A와 B가 친구인가?”를 판단할 때는  
단지 “이 두 사람을 묶는 ACCEPTED 관계가 존재하는지”만 보면 됩니다.

쿼리 관점에서는:

- `isFriend(A,B)`  
  - `(requesterId = A AND receiverId = B) OR (requesterId = B AND receiverId = A)`  
    AND `status = ACCEPTED`

이렇게 **방향성을 무시한 조건**으로 처리하면,  
현재 친구 관계는 대칭으로 해석되기 때문에,  
`requester/receiver`의 비대칭은 단지 “과거의 방향”일 뿐이 됩니다.

### 4.2. 이름이 거슬린다면 바꿔볼 수 있는 패턴들

그래도 `requester/receiver`라는 단어 자체가 신경 쓰인다면,  
이런 식으로 리팩터링할 여지도 있습니다.

- `memberAId`, `memberBId`, `initiatedBy`  
  - 관계의 두 쪽은 대칭적인 이름으로 두고  
  - 누가 먼저 시작했는지는 `initiatedBy`에만 기록
- `memberLowId`, `memberHighId`, `initiatorId`  
  - 항상 더 작은 id를 왼쪽에 두는 규칙으로 “쌍” 자체는 완전히 대칭으로 표현

즉, 비대칭이 “개념 문제”라기보다는, **어휘/표현의 문제**에 가깝다는 결론에 이르렀습니다.

---

## 5. 마지막 확인: 친구 끊기(언프렌드) 동작은 어떻게 되나?

마지막으로 확인하고 싶었던 부분은 이것입니다.

> “그러면 이 모델의 경우 누군가 친구 관계를 끊으면 서로 모두 알 수 있겠네요?  
> 하지만 Giftify는 친구 관계가 일급 시민이니까 그게 맞는 모델링이고요?”

여기서 결정이 확실해졌습니다.

- Friendship은 “두 사람 사이의 단 하나의 관계 객체”입니다.
- 한쪽이 “친구 끊기”를 하면:
  - Friendship을 삭제하거나 상태를 TERMINATED/DELETED로 변경
  - 그 순간부터 두 사람 모두 `isFriend = false`
- 즉, **관계 자체가 사라지므로, 둘 다 동시에 친구가 아니다**가 됩니다.

이 동작은 Giftify의 요구사항과 잘 맞았습니다.

- Giftify에서 “친구 여부”는 위시리스트 공개 범위(공개/친구공개/비공개)와  
  펀딩 가능 여부(“친구의 위시리스트에만 펀딩 허용” 같은 정책)에 직결됩니다.
- 따라서 “친구인가?”는 서비스 전체에서 매우 중요한 질문이고,  
  그 답을 책임지는 **Friendship 엔티티가 일급 시민**으로 존재하는 편이 도메인적으로 더 자연스럽습니다.

반대로, Follow 두 개로 친구를 정의했다면:

- A가 B 팔로우를 끊어도, B→A는 그대로일 수 있고,
- 양방향 Follow 중 무엇이 언제 끊겼는지에 따라  
  “이걸 친구 해제라고 볼지?”, “한쪽만 더 이상 친구라고 인식하는 상태를 허용할지?” 같은 복잡한 케이스를 모두 다뤄야 합니다.

Giftify처럼 **“친구 기반 기능”이 메인인 서비스**에서는,  
차라리 “둘 사이의 친구 관계 하나”를 명시적으로 모델링하고,  
이걸 기준으로 접근 제어/펀딩 정책을 세우는 편이 훨씬 명료합니다.

---

## 6. 정리: Giftify에서 선택한 방향

질문과 답변을 쭉 따라간 뒤, Giftify 친구 관계 모델링에 대한 결론은 이렇게 정리할 수 있습니다.

1. **Friendship = Member–Member 사이의 N:N 관계를 푸는 중간 엔티티**  
   - 하지만 단순 조인 테이블이 아니라,  
     “친구”라는 도메인 개념을 표현하는 **일급 시민 엔티티**이다.

2. **페이스북식 요청/수락 모델**  
   - `requesterId/receiverId/status`를 가진 한 줄이 “두 사람의 친구 관계 전체”를 의미한다.  
   - ACCEPTED가 되면, 방향성과 무관하게 둘은 친구다.

3. **인스타식 Follow 두 개로도 친구를 정의할 수 있지만,**  
   - 그 경우 “친구”는 규칙/쿼리 안에서만 존재하는 파생 개념이 된다.  
   - Giftify처럼 친구 여부가 중요한 도메인에서는 오히려 더 복잡해질 수 있다.

4. **requester/receiver의 비대칭은 “과거의 방향성”으로만 해석**  
   - 현재 관계는 대칭(둘 다 친구)  
   - 비대칭이 거슬리면 `memberA/B + initiatedBy` 같은 형태로 이름을 바꾸는 방향도 있다.

5. **언프렌드 = 관계 객체의 종료**  
   - 한쪽이 친구를 끊으면, 두 사람 모두 더 이상 친구가 아니다.  
   - 이것이 “친구 관계가 일급 시민”인 Giftify의 의도와 잘 맞는다.

이 과정을 통해, 단순히 “어떤 테이블 구조가 깔끔한가?”를 넘어서,  
“우리 도메인에서 진짜로 중요한 1급 개념이 무엇인가?”를 기준으로 모델을 선택하게 되었습니다.  
Giftify에서는 그게 바로 **Friendship**이었고,  
그에 맞는 모델을 택했다는 점이 이번 트러블슈팅의 최종 결론입니다.
